<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathe Arbeitsblatt Generator - 2. Klasse</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Nunito:wght@400;700&display=swap');

        :root {
            --primary-color: #4facfe;
            --secondary-color: #00f2fe;
            --accent-color: #ff9a9e;
            --text-color: #333;
            --bg-color: #f0f4f8;
            --sheet-bg: #fff;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(120deg, var(--bg-color), #d9e2ec);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Control Panel (Screen Only) */
        .controls {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 800px;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        select {
            padding: 12px 20px;
            font-size: 1rem;
            border-radius: 12px;
            border: 2px solid #ddd;
            background-color: white;
            color: var(--text-color);
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s;
            font-family: 'Nunito', sans-serif;
        }

        select:focus {
            border-color: var(--primary-color);
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 700;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Nunito', sans-serif;
        }

        .btn-generate {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .btn-print {
            background: linear-gradient(135deg, var(--accent-color), #fecfef);
            color: white;
        }

        .btn-check {
            background: linear-gradient(135deg, #42e695, #3bb2b8);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        /* Print Optimization */
        @page {
            size: A4;
            margin: 0;
            /* Let the body/sheet handle margins */
        }

        /* Worksheet (Screen Preview & Print) */
        .sheet {
            background: var(--sheet-bg);
            width: 210mm;
            min-height: 297mm;
            padding: 15mm;
            /* Reduced padding */
            box-sizing: border-box;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            position: relative;
            font-family: 'Comic Neue', cursive;
            font-size: 16pt;
            /* Slightly smaller font */
            margin: auto;
            /* Center on screen */
        }

        .sheet-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            /* Reduced margin */
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .header-field {
            display: flex;
            align-items: baseline;
            gap: 10px;
        }

        .line {
            border-bottom: 1px solid #000;
            width: 150px;
            display: inline-block;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 25px;
            /* Reduced margin */
            font-size: 22pt;
            /* Slightly smaller */
            margin-top: 0;
        }

        .problem-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: 40px;
            row-gap: 25px;
            /* Reduced gap */
        }

        .problem {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            /* Reduced padding */
            /* border-bottom: 1px dashed #eee; */
            /* Optional guide lines */
        }

        .number {
            width: 50px;
            /* Adjusted width */
            text-align: right;
        }

        .operator {
            width: 25px;
            text-align: center;
        }

        .equals {
            width: 25px;
            text-align: center;
        }

        .answer-box {
            width: 70px;
            height: 35px;
            border: 2px solid #ccc;
            border-radius: 8px;
            background-color: #fafafa;
            display: inline-block;
            vertical-align: middle;
        }

        /* Input Styles */
        input.answer-input {
            width: 70px;
            height: 35px;
            border: 2px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            font-family: 'Comic Neue', cursive;
            font-size: 16pt;
            text-align: center;
            color: var(--text-color);
            outline: none;
            transition: all 0.3s ease;
        }

        input.answer-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 5px rgba(79, 172, 254, 0.5);
        }

        input.answer-input.correct {
            border-color: #2ecc71;
            background-color: #e8f8f5;
            color: #27ae60;
        }

        input.answer-input.incorrect {
            border-color: #e74c3c;
            background-color: #fadbd8;
            color: #c0392b;
        }

        .footer {
            position: absolute;
            /* Fix footer to bottom */
            bottom: 15mm;
            left: 0;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 10pt;
        }

        /* Motivational Emoji */
        .mascot {
            position: absolute;
            bottom: 15mm;
            /* Match footer area */
            right: 15mm;
            /* Match padding */
            font-size: 3rem;
            opacity: 0.8;
        }

        /* Rechenmauer (Pyramid) Styles */
        .pyramid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-bottom: 20px;
        }

        .pyramid-row {
            display: flex;
            justify-content: center;
            gap: 5px;
            /* Gap between bricks */
        }

        .brick {
            width: 60px;
            height: 35px;
            border: 2px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14pt;
            background-color: #fff;
            position: relative;
        }

        /* Input brick vs Fixed brick styling */
        .brick.input {
            background-color: #fafafa;
            color: transparent;
            /* Text hidden if it was there contextually, but mainly we use empty div */
        }

        /* Ensure inputs fit in bricks if we used input elements, but we might just use empty bricks for kids to write in */
        input.brick-input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-family: inherit;
            font-size: inherit;
            background: transparent;
            color: inherit;
            outline: none;
        }

        .brick.input.correct {
            background-color: #e8f8f5;
            border-color: #2ecc71;
            color: #27ae60;
        }

        .brick.input.incorrect {
            background-color: #fadbd8;
            border-color: #e74c3c;
            color: #c0392b;
        }

        @media print {

            body,
            html {
                margin: 0;
                padding: 0;
                background: none;
                width: 210mm;
                height: auto;
            }

            /* Ensure pyramids don't break across pages awkwardly (though grid handles most) */
            .pyramid-container {
                page-break-inside: avoid;
            }

            .controls {
                display: none;
            }

            /* Print friendly inputs */
            input.answer-input,
            input.brick-input {
                border: 2px solid #ccc;
                /* Maintain border for writing */
                background: none;
                color: transparent;
                /* Hide user answers when printing empty sheets, but show if we want? Usually we want empty.*/
            }

            /* Actually, if user wants to print the filled sheet -> color: black. 
               If user wants to print empty sheet -> they just generate and print. 
               So Color should be black. */
            input.answer-input,
            input.brick-input {
                color: #000;
            }

            .sheet {
                box-shadow: none;
                margin: 0;
                width: 100%;
                height: auto;
                page-break-after: always;
                break-after: page;
                border: none;
            }

            .sheet:last-child {
                page-break-after: auto;
                break-after: auto;
            }
        }
    </style>
</head>

<body>

    <div class="controls">
        <select id="gradeSelector" onchange="updateTopicSelector()">
            <option value="1">1. Klasse</option>
            <option value="2" selected>2. Klasse</option>
            <option value="3">3. Klasse</option>
        </select>
        <select id="topicSelector">
            <!-- Options populated by JS -->
        </select>
        <div style="display:flex; align-items:center;">
            <input type="checkbox" id="solutionToggle" style="width:20px; height:20px; margin-right:5px;"
                onchange="renderCurrentState()">
            <label for="solutionToggle">L√∂sungsblatt</label>
        </div>
        <button class="btn-generate" onclick="generateSheet()">‚ú® Neue Aufgaben</button>
        <!-- Check button removed in favor of real-time validation -->
        <button class="btn-print" onclick="window.print()">üñ®Ô∏è Drucken</button>
    </div>

    <div id="sheetsWrapper">
        <!-- Sheets will be inserted here -->
    </div>

    <script>
        const mascots = ['ü¶ä', 'ü¶â', 'ü¶Å', 'üêº', 'üê®', 'üêØ', 'ü¶Ñ', 'ü¶ñ'];

        const GRADE_TOPICS = {
            '1': [
                { value: 'add_10', text: 'Addition bis 10' },
                { value: 'sub_10', text: 'Subtraktion bis 10' },
                { value: 'add_20_simple', text: 'Addition bis 20 (ohne Zehner√ºbergang)' },
                { value: 'sub_20_simple', text: 'Subtraktion bis 20 (ohne Zehner√ºbergang)' },
                { value: 'bonds_10', text: 'Verliebte Zahlen (bis 10)' },
                { value: 'rechenmauer_10', text: 'Kleine Rechenmauern (bis 10)' }
            ],
            '2': [
                { value: 'add_20', text: 'Addition bis 20 (mit Zehner√ºbergang)' },
                { value: 'sub_20', text: 'Subtraktion bis 20 (mit Zehner√ºbergang)' },
                { value: 'add_100_simple', text: 'Addition bis 100 (ohne Zehner√ºbergang)' },
                { value: 'add_100_carry', text: 'Addition bis 100 (mit Zehner√ºbergang)' },
                { value: 'sub_100_simple', text: 'Subtraktion bis 100 (ohne Zehner√ºbergang)' },
                { value: 'sub_100_carry', text: 'Subtraktion bis 100 (mit Zehner√ºbergang)' },
                { value: 'mult_2_5_10', text: 'Kleines 1x1 (2er, 5er, 10er)' },
                { value: 'mult_all', text: 'Kleines 1x1 (Gemischt)' },
                { value: 'div_2_5_10', text: 'Geteilt (2er, 5er, 10er)' },
                { value: 'rechenmauer', text: 'Rechenmauern (Zahlenmauern)' },
                { value: 'rechenmauer_4', text: 'Rechenmauern (4 Ebenen)' },
                { value: 'word_problems', text: 'Sachrechnen (Textaufgaben)' }
            ],
            '3': [
                { value: 'add_1000', text: 'Addition bis 1000' },
                { value: 'sub_1000', text: 'Subtraktion bis 1000' },
                { value: 'mult_advanced', text: 'Erweitertes 1x1 (bis 20)' }, // Or large mult placeholders
                { value: 'div_100', text: 'Division (bis 100 ohne Rest)' },
                { value: 'div_remainder', text: 'Division (mit Rest - Basis)' },
                { value: 'rechenmauer_100', text: 'Gro√üe Rechenmauern (bis 100)' }
            ]
        };

        function updateTopicSelector() {
            const grade = document.getElementById('gradeSelector').value;
            const topicSelector = document.getElementById('topicSelector');
            const topics = GRADE_TOPICS[grade];

            topicSelector.innerHTML = '';
            topics.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.value;
                opt.textContent = t.text;
                topicSelector.appendChild(opt);
            });

            // Trigger generation with new first topic
            generateSheet();
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function generateProblem(type) {
            let a, b, op;

            switch (type) {
                // --- GRADE 1 ---
                case 'add_10':
                    a = getRandomInt(0, 9);
                    b = getRandomInt(1, 10 - a);
                    op = '+';
                    break;
                case 'sub_10':
                    a = getRandomInt(1, 10);
                    b = getRandomInt(1, a);
                    op = '-';
                    break;
                case 'add_20_simple': // No crossing 10, e.g. 12+3
                    a = getRandomInt(10, 18); // Start at 10 to ensure teen number
                    b = getRandomInt(1, 19 - a);
                    op = '+';
                    break;
                case 'sub_20_simple': // No crossing 10, e.g. 15-3
                    a = getRandomInt(11, 19);
                    b = getRandomInt(1, a - 10); // Ensure result remains >= 10
                    op = '-';
                    break;
                case 'bonds_10': // Verliebte Zahlen: 3 + _ = 10
                    // We'll handle visual rendering in the loop, here just data
                    a = getRandomInt(0, 10);
                    return { type: 'missing_addend', a: a, sum: 10, op: '+' };

                case 'rechenmauer_10':
                    return generatePyramid(10);

                // --- GRADE 2 (Legacy + Refined) ---
                case 'add_20':
                    // Keep existing logic: random sum to 20
                    a = getRandomInt(1, 19);
                    b = getRandomInt(1, 20 - a);
                    op = '+';
                    break;
                case 'sub_20':
                    a = getRandomInt(1, 20);
                    b = getRandomInt(1, a);
                    op = '-';
                    break;
                case 'add_100_simple': // No carry
                    a = getRandomInt(1, 89);
                    {
                        let a_ones = a % 10;
                        b = getRandomInt(1, 99 - a);
                        while ((b % 10) + a_ones >= 10) {
                            b = getRandomInt(1, 99 - a);
                        }
                    }
                    op = '+';
                    break;
                case 'add_100_carry': // Forced carry
                    do {
                        a = getRandomInt(10, 89);
                        b = getRandomInt(1, 99 - a);
                    } while ((a % 10) + (b % 10) < 10);
                    op = '+';
                    break;
                case 'sub_100_simple': // No borrowing
                    a = getRandomInt(10, 99);
                    {
                        let max_b_ones = a % 10;
                        let max_b_tens = Math.floor(a / 10);
                        let b_tens = getRandomInt(0, max_b_tens);
                        let b_ones = getRandomInt(0, max_b_ones);
                        b = b_tens * 10 + b_ones;
                        if (b === 0) b = 1;
                    }
                    op = '-';
                    break;
                case 'sub_100_carry': // Forced borrowing
                    do {
                        a = getRandomInt(20, 99);
                        b = getRandomInt(1, a - 1);
                    } while ((a % 10) >= (b % 10));
                    op = '-';
                    break;
                case 'mult_2_5_10':
                    b = [2, 5, 10][getRandomInt(0, 2)];
                    a = getRandomInt(1, 10);
                    op = '√ó';
                    break;
                case 'mult_all':
                    a = getRandomInt(1, 10);
                    b = getRandomInt(1, 10);
                    op = '√ó';
                    break;
                case 'div_2_5_10':
                    {
                        let divisor = [2, 5, 10][getRandomInt(0, 2)];
                        let result = getRandomInt(1, 10);
                        a = result * divisor;
                        b = divisor;
                    }
                    op = ':';
                    break;
                case 'rechenmauer':
                    return generatePyramid(100, 3);
                case 'rechenmauer_4':
                    return generatePyramid(100, 4);
                case 'word_problems':
                    // Existing word problems (could be graded too, but keeping simple for now)
                    const problems = [
                        { q: "Lisa hat 5 √Ñpfel. Sie kauft 3 dazu. Wie viele hat sie?", a: 8 },
                        { q: "Tom hat 10 Ballons. 2 fliegen weg. Wie viele bleiben?", a: 8 },
                        { q: "Eine Katze hat 4 Beine. Wie viele Beine haben 2 Katzen?", a: 8 },
                        { q: "Oma backt 12 Kekse. Sie verteilt sie an 3 Enkel. Wie viele kriegt jeder?", a: 4 },
                        { q: "Im Bus sind 5 Leute. An der Haltestelle steigen 4 ein. Wie viele sind es?", a: 9 },
                        { q: "Max hat 20 Franken. Ein Buch kostet 15. Wie viel bleibt √ºbrig?", a: 5 }
                    ];
                    return { type: 'text', ...problems[getRandomInt(0, problems.length - 1)] };

                // --- GRADE 3 ---
                case 'add_1000':
                    a = getRandomInt(100, 899);
                    b = getRandomInt(1, 999 - a);
                    op = '+';
                    break;
                case 'sub_1000':
                    a = getRandomInt(100, 999);
                    b = getRandomInt(1, a - 1);
                    op = '-';
                    break;
                case 'mult_advanced':
                    // e.g. 15 * 4
                    a = getRandomInt(11, 20);
                    b = getRandomInt(2, 6); // Keep multipliers manageable
                    op = '√ó';
                    break;
                case 'div_100':
                    {
                        // Inverse of 1x1 mixed
                        let divisor = getRandomInt(2, 9);
                        let result = getRandomInt(2, 10);
                        a = result * divisor;
                        b = divisor;
                    }
                    op = ':';
                    break;
                case 'div_remainder':
                    {
                        // a / b = result R remainder
                        let divisor = getRandomInt(2, 9);
                        let result = getRandomInt(2, 10);
                        let remainder = getRandomInt(1, divisor - 1);
                        a = (result * divisor) + remainder;
                        b = divisor;
                    }
                    op = ':';
                    return { type: 'div_remainder', a, b, op };

                case 'rechenmauer_100': // Actually same as grade 2 limit but user might want harder masking? 
                    // Let's go up to 200 for grade 3? Or just stick to 100 but maybe harder start?
                    // Standard Grade 3 adds numbers up to 1000, so pyramid sum could go higher?
                    // Defaulting to 200 top.
                    return generatePyramid(200, 3);
            }
            return { a, b, op };
        }

        function generatePyramid(maxTop, levels = 3) {
            let values = [];
            let mask = [];

            // Re-implementing generation bottom-up with flat array
            // Layers are stored sequentially bottom to top.
            let top;
            do {
                values = [];
                // 1. Generate Base
                let baseCount = levels;
                let maxBase = Math.floor(maxTop / (2 ** (levels - 1)));
                if (maxBase < 1) maxBase = 1;

                // Push base layer
                for (let i = 0; i < baseCount; i++) {
                    values.push(getRandomInt(1, maxBase));
                }

                // 2. Calculate upper layers
                let currentLayerStart = 0;
                let currentLayerLength = baseCount;

                for (let l = 1; l < levels; l++) {
                    // Next layer has currentLayerLength - 1 elements
                    for (let i = 0; i < currentLayerLength - 1; i++) {
                        let val = values[currentLayerStart + i] + values[currentLayerStart + i + 1];
                        values.push(val);
                    }
                    currentLayerStart += currentLayerLength;
                    currentLayerLength--;
                }

                top = values[values.length - 1];

            } while (top > maxTop);

            // Generate Mask
            // Just simple random masking for now. 
            const totalItems = values.length;
            const itemsToHide = Math.floor(totalItems * 0.5); // 50% hidden

            mask = new Array(totalItems).fill(false);

            // Ensure we don't hide everything.
            let hiddenCount = 0;
            while (hiddenCount < itemsToHide) {
                let idx = getRandomInt(0, totalItems - 1);
                if (!mask[idx]) {
                    mask[idx] = true;
                    hiddenCount++;
                }
            }

            return {
                type: 'pyramid',
                levels: levels,
                values: values,
                mask: mask
            };
        }

        // --- NEW RENDERING ARCHITECTURE ---

        function generateProblemsData(type, count) {
            const data = [];
            for (let i = 0; i < count; i++) {
                data.push(generateProblem(type));
            }
            return data;
        }

        function createProblemElement(problemData, isSolution) {
            const problemDiv = document.createElement('div');
            problemDiv.className = 'problem';

            if (problemData.type === 'text') {
                problemDiv.style.flexDirection = 'column';
                problemDiv.style.alignItems = 'flex-start';
                problemDiv.style.borderBottom = '1px solid #eee';
                problemDiv.style.paddingBottom = '10px';

                const answerVal = isSolution ? problemData.a : '';
                const correctClass = isSolution ? 'correct-answer-show' : ''; // custom class if needed

                problemDiv.innerHTML = `
                        <div style="font-size: 14pt; margin-bottom:10px;">${problemData.q}</div>
                        <div style="display:flex; gap:10px; align-items:center; width:100%; justify-content: flex-end;">
                            <span>Antwort:</span>
                            <input type="number" class="answer-input ${correctClass}" style="width:100px;" 
                                   data-expected="${problemData.a}" 
                                   value="${answerVal}" 
                                   oninput="validateInput(this)" 
                                   ${isSolution ? 'readonly style="color:var(--primary-color); font-weight:bold;"' : ''}>
                        </div>
                    `;

            } else if (problemData.type === 'pyramid') {
                const v = problemData.values;
                const m = problemData.mask;
                const levels = problemData.levels || 3;

                const renderBrick = (idx) => {
                    if (idx >= v.length) return '';
                    const val = v[idx];
                    const isHidden = m[idx];

                    if (isHidden) {
                        const valueToFill = isSolution ? val : '';
                        const style = isSolution ? 'color:var(--primary-color); font-weight:bold;' : '';
                        return `<div class="brick input"><input type="number" class="brick-input answer-input" 
                                    data-expected="${val}" 
                                    value="${valueToFill}"
                                    oninput="validateInput(this)"
                                    ${isSolution ? 'readonly' : ''} style="${style}"></div>`;
                    } else {
                        return `<div class="brick">${val}</div>`;
                    }
                };

                let html = '<div class="pyramid-container">';

                let currentStartIndex = 0;
                let rowStarts = [];
                let currentRowLen = levels;
                for (let l = 0; l < levels; l++) {
                    rowStarts.push(currentStartIndex);
                    currentStartIndex += currentRowLen;
                    currentRowLen--;
                }

                // Render from Top (last layer) down to Base (layer 0)
                for (let l = levels - 1; l >= 0; l--) {
                    let startIdx = rowStarts[l];
                    let count = levels - l;

                    html += '<div class="pyramid-row">';
                    for (let i = 0; i < count; i++) {
                        html += renderBrick(startIdx + i);
                    }
                    html += '</div>';
                }

                html += '</div>';

                problemDiv.innerHTML = html;
                problemDiv.style.display = 'block';
                problemDiv.style.padding = '0';

            } else if (problemData.type === 'missing_addend') {
                const { a, sum, op } = problemData;
                const expected = sum - a;
                const val = isSolution ? expected : '';
                const style = isSolution ? 'color:var(--primary-color); font-weight:bold;' : '';

                problemDiv.innerHTML = `
                        <span class="number">${a}</span>
                        <span class="operator">${op}</span>
                        <input type="number" class="answer-input" style="width:50px; margin:0 5px; ${style}" 
                               data-expected="${expected}" 
                               value="${val}"
                               oninput="validateInput(this)" ${isSolution ? 'readonly' : ''}>
                        <span class="equals">=</span>
                        <span class="number">${sum}</span>
                    `;

            } else if (problemData.type === 'div_remainder') {
                const { a, b, op } = problemData;
                const quotient = Math.floor(a / b);
                const remainder = a % b;

                const valQ = isSolution ? quotient : '';
                const valR = isSolution ? remainder : '';
                const style = isSolution ? 'color:var(--primary-color); font-weight:bold;' : '';

                problemDiv.innerHTML = `
                        <span class="number">${a}</span>
                        <span class="operator">${op}</span>
                        <span class="number">${b}</span>
                        <span class="equals">=</span>
                        <input type="number" class="answer-input" style="width:40px; margin-right:5px; ${style}" 
                               data-expected="${quotient}" value="${valQ}" oninput="validateInput(this)" ${isSolution ? 'readonly' : ''}>
                        <span style="font-size:12pt; margin-right:5px;">R</span>
                        <input type="number" class="answer-input" style="width:40px; ${style}" 
                               data-expected="${remainder}" value="${valR}" oninput="validateInput(this)" ${isSolution ? 'readonly' : ''}>
                    `;

            } else {
                // Standard
                const { a, b, op } = problemData;
                let expected;
                if (op === '+') expected = a + b;
                else if (op === '-') expected = a - b;
                else if (op === '√ó') expected = a * b;
                else if (op === ':') expected = a / b;

                const val = isSolution ? expected : '';
                const style = isSolution ? 'color:var(--primary-color); font-weight:bold;' : '';

                problemDiv.innerHTML = `
                        <span class="number">${a}</span>
                        <span class="operator">${op}</span>
                        <span class="number">${b}</span>
                        <span class="equals">=</span>
                        <input type="number" class="answer-input" style="${style}" data-expected="${expected}" value="${val}" oninput="validateInput(this)" ${isSolution ? 'readonly' : ''}>
                    `;
            }
            return problemDiv;
        }

        function createSheetElement(titleText, problemDataList, isSolution) {
            // Create Sheet
            const sheetDiv = document.createElement('div');
            sheetDiv.className = 'sheet';

            // Header
            const header = document.createElement('div');
            header.className = 'sheet-header';
            header.innerHTML = `
                <div class="header-field">Name: <span class="line"></span></div>
                <div class="header-field">Datum: <span class="line"></span></div>
             `;
            sheetDiv.appendChild(header);

            // Title
            const h1 = document.createElement('h1');
            h1.textContent = titleText + (isSolution ? ' (L√∂sungen)' : '');
            if (isSolution) h1.style.color = '#27ae60';
            sheetDiv.appendChild(h1);

            // Grid
            const grid = document.createElement('div');
            grid.className = 'problem-grid';

            // Check layout needs
            // We can infer layout from the first problem or pass it as arg
            // But existing code checked 'type' string. Let's inspect first problem to guess or stick to global 'type' passed down?
            // Simplest is to pass the 'type' string to this function or check content.
            // problemDataList[0].type ...

            // Let's rely on standard Layout unless it's a pyramid.
            const isPyramid = problemDataList.length > 0 && problemDataList[0].type === 'pyramid';

            if (isPyramid) {
                const levels = problemDataList[0].levels || 3;

                grid.style.gridTemplateColumns = '1fr 1fr';
                grid.style.columnGap = '20px';
                grid.style.rowGap = '25px';
            } else {
                grid.style.gridTemplateColumns = '1fr 1fr';
                grid.style.columnGap = '40px';
                grid.style.rowGap = '25px';
            }

            problemDataList.forEach(p => {
                grid.appendChild(createProblemElement(p, isSolution));
            });

            sheetDiv.appendChild(grid);

            sheetDiv.appendChild(grid);

            // Layout adjustments: Removed Mascot and Footer per user request

            return sheetDiv;
        }

        let currentProblemData = [];
        let currentTitle = "";

        function generateSheet() {
            const selector = document.getElementById('topicSelector');
            const type = selector.value;
            currentTitle = selector.options[selector.selectedIndex].text;

            // 1. Determine Count
            let numProblems = 20;
            if (type === 'word_problems') numProblems = 8;
            if (type === 'rechenmauer_4') numProblems = 6; // 4-layer pyramids are large
            else if (type.includes('rechenmauer')) numProblems = 9; // 3-layer pyramids


            // 2. Generate Data
            currentProblemData = generateProblemsData(type, numProblems);

            // 3. Render
            renderCurrentState();
        }

        function renderCurrentState() {
            const wrapper = document.getElementById('sheetsWrapper');
            const showSolutions = document.getElementById('solutionToggle').checked;

            wrapper.innerHTML = '';

            // Render Worksheet
            const worksheet = createSheetElement(currentTitle, currentProblemData, false);
            wrapper.appendChild(worksheet);

            // Render Solution Sheet if requested
            if (showSolutions) {
                const solutionSheet = createSheetElement(currentTitle, currentProblemData, true);
                wrapper.appendChild(solutionSheet);
            }
        }

        function validateInput(input) {
            const expected = parseInt(input.dataset.expected);
            const value = parseInt(input.value);

            // For pyramids, the parent brick needs styling
            const isBrick = input.classList.contains('brick-input');
            const target = isBrick ? input.parentElement : input;

            if (isNaN(value)) {
                // If empty or invalid, just remove classes for neutral state
                target.classList.remove('correct', 'incorrect');
                return;
            }

            if (value === expected) {
                target.classList.add('correct');
                target.classList.remove('incorrect');
                checkAllDone();
            } else {
                target.classList.add('incorrect');
                target.classList.remove('correct');
            }
        }

        function checkAllDone() {
            const inputs = document.querySelectorAll('.answer-input');
            let allCorrect = true;
            inputs.forEach(input => {
                const expected = parseInt(input.dataset.expected);
                const value = parseInt(input.value);
                // If any input is not correct or is empty, it's not all done
                if (isNaN(value) || value !== expected) {
                    allCorrect = false;
                }
            });

            const mascot = document.getElementById('mascot');
            if (allCorrect) {
                mascot.textContent = 'üéâ';
                // Optional: Celebration effect, but alert might be annoying if it pops up on last keystroke immediately.
                // let's just stick to mascot change.
            } else {
                // mascot.textContent = 'ü¶ä'; // Default
            }
        }

        // Initialize on load
        window.onload = function () {
            updateTopicSelector(); // This will also call generateSheet
        };
    </script>
</body>

</html>